<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AxoNet_.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">axonet</a> &gt; <a href="index.source.html" class="el_package">gt.ethier.axonet</a> &gt; <span class="el_source">AxoNet_.java</span></div><h1>AxoNet_.java</h1><pre class="source lang-java linenums">package gt.ethier.axonet;


import ij.ImagePlus;
import ij.measure.Calibration;
import ij.WindowManager;
import ij.process.ImageProcessor;
import ij.process.FloatProcessor;
import ij.process.ImageConverter;

import java.util.List;

import net.imagej.DatasetService;
import net.imagej.tensorflow.TensorFlowService;
//import net.imglib2.type.numeric.RealType;

import org.scijava.command.Command;
import org.scijava.io.http.HTTPLocation;
import org.scijava.log.LogService;
import org.scijava.plugin.Parameter;
import org.scijava.plugin.Plugin;
import org.scijava.log.LogLevel;

import org.tensorflow.SavedModelBundle;
import org.tensorflow.Tensor;
import org.tensorflow.framework.MetaGraphDef;
import org.tensorflow.framework.SignatureDef;
import org.tensorflow.framework.TensorInfo;

import com.google.protobuf.InvalidProtocolBufferException;

import java.util.Objects;


import org.la4j.Matrix;
import org.la4j.Vector;




//@Plugin(type = Command.class, menuPath = &quot;Plugins&gt;AxoNet_&quot;)
@Plugin(type = Command.class, menuPath = &quot;Plugins &gt; AxoNet_&quot;, selectable = true)
<span class="nc" id="L43">public class AxoNet_ implements Command {</span>
		
		//define model identifiers
		//explained in https://www.tensorflow.org/api_docs/python/tf/saved_model/simple_save
		//private static final String MODEL_URL = &quot;https://drive.google.com/uc?export=download&amp;id=1G20emdYbT2-VOpGjLsqaPqyFdXjTSs1W&quot;;
		private static final String MODEL_URL = &quot;https://drive.google.com/uc?export=download&amp;id=1rGN47Pgq-XPolb8CnOX8n3G3lg550xwF&quot;;
		//private static final String MODEL_URL = &quot;https://drive.google.com/uc?export=download&amp;id=1G20emdYbT2-VOpGjLsqaPqyFdXjTSs1W&quot;;;
		private static final String MODEL_NAME = &quot;model_3&quot;; 
		// Same as the tag used in export_saved_model in the Python code.
		private static final String MODEL_TAG = &quot;serve&quot;;  //check when saving model
		private static final String DEFAULT_SERVING_SIGNATURE_DEF_KEY =&quot;serving_default&quot;; //leave unchanged
		private static final int TILE_SIZE =256; //mess with this to optimize performance. Should keep around this size, must be multiple of 32.
		//define services for our plugin
		@Parameter
		private static TensorFlowService tensorFlowService; //service for working with tensorflow    https://javadoc.scijava.org/ImageJ/net/imagej/tensorflow/TensorFlowService.html
		@Parameter
		private DatasetService datasetService; //service for working with datasets    https://javadoc.scijava.org/ImageJ/net/imagej/DatasetService.html	
		@Parameter
		private static LogService log; //sets up log service	
		//@Parameter(label = &quot;Optic Nerve Cross Section&quot;)
		//private Img&lt;T&gt; originalImage;
		
		//TODO add these
		/*
		@Parameter(label = &quot;&lt;html&gt;Do you want a grid overlay on the final full count display? &quot; + &quot;This may help with viewing a large image's results.&quot;, persist = false,                          
				description = &quot;&lt;html&gt;Do you want a grid overlay on the final full count display? &quot; +
					&quot;This may help with viewing a large image's results.&quot;)
			private boolean grid = true;
		@Parameter(label = &quot;&lt;html&gt;Do you want a .csv output file of the pixelwise count densities used to calculate the full count?&quot;, persist = false,                          
				description = &quot;&lt;html&gt; prints result count density to .csv in home folder&quot;)
			private boolean csvOut = true;
		*/
		
		@Override
		public void run() {
			
			
			
			
			
			//load image
<span class="nc" id="L84">			ImagePlus img = WindowManager.getCurrentImage(); </span>
			
<span class="nc bnc" id="L86" title="All 2 branches missed.">			if (Objects.isNull(img)) {</span>
<span class="nc" id="L87">				log.error(&quot;Load an image before running the plugin&quot;);</span>
			}
			
<span class="nc" id="L90">			ImageProcessor imp = img.getProcessor(); </span>
<span class="nc" id="L91">			ImageConverter inc= new ImageConverter(img);</span>
			
<span class="nc" id="L93">			ImagePlus progress = new ImagePlus(&quot;Running AxoNet&quot;, imp);</span>
<span class="nc" id="L94">			ImageProcessor grayscale = imp.convertToFloat();</span>
<span class="nc" id="L95">			progress.setProcessor(grayscale);</span>
<span class="nc" id="L96">			img.close();</span>
<span class="nc" id="L97">			progress.show();</span>
			
			//check scale
			//set to default if scale is 0 TODO make this more robust
<span class="nc" id="L101">			Calibration cal = img.getCalibration(); </span>
<span class="nc" id="L102">			double scale = 15.7;</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">			if (cal.pixelWidth != 0) {</span>
<span class="nc" id="L104">				scale = 1.0 / cal.pixelWidth;</span>
			}
			
			//define sizing 
<span class="nc" id="L108">			int height = grayscale.getHeight();</span>
<span class="nc" id="L109">			int width = grayscale.getWidth();</span>
<span class="nc" id="L110">			double compensate = 15.7/scale;</span>
			
			//rescale, redefine total height and width, and set tile sizes
			//TODO add input here from user to correct scale
			try {
<span class="nc" id="L115">				grayscale.resize((int) compensate*width, (int) compensate*height);</span>
<span class="nc" id="L116">			}</span>
<span class="nc" id="L117">			catch (Exception e) {</span>
<span class="nc" id="L118">				String msg = (&quot;make sure you set your image's scale properly.\nImage was not able to be resized.\n&quot;);</span>
<span class="nc" id="L119">				log.log(LogLevel.INFO, msg);</span>
				//log.info(msg);
			}
			
<span class="nc" id="L123">			height = grayscale.getHeight();</span>
<span class="nc" id="L124">			width = grayscale.getWidth();</span>
			
<span class="nc" id="L126">			int tileCountRow = Math.round(height/TILE_SIZE);</span>
<span class="nc" id="L127">			int tileCountCol = Math.round(width/TILE_SIZE);</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">			if (tileCountRow==0) { tileCountRow=1;}</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">			if (tileCountCol==0) { tileCountCol=1;}</span>
			
			
			//TODO this might leave off 1 - tileCount(Row/Col) pixels on any side. correct if this becomes an issue
<span class="nc" id="L133">			int tileWidth = (int) Math.floor(width/tileCountCol);</span>
<span class="nc" id="L134">			int tileHeight = (int) Math.floor(height/tileCountRow);</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">			if (tileWidth%2!=0) { tileWidth=tileWidth-1;}</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">			if (tileHeight%2!=0) { tileHeight=tileHeight-1;}</span>
			
			
			//define mirroring
<span class="nc" id="L140">			int mirrorMin = 16;</span>
<span class="nc" id="L141">			int mirrorNheight = mirrorMin + (32-(tileHeight+2*mirrorMin)%32)/2; //mirrorMin minimum but adds to cover size issues on edges</span>
<span class="nc" id="L142">			int mirrorNwidth = mirrorMin + (32-(tileWidth+2*mirrorMin)%32)/2; //mirrorMin minimum but adds to cover size issues on edges</span>
			
			
			//load model
<span class="nc" id="L146">			SavedModelBundle model = getModel();</span>
			
			//manipulate image
<span class="nc" id="L149">			final int ndims = img.getNDimensions();</span>
						
			
			//make image matrix- this transposes the image because of the way imageJ works.
<span class="nc" id="L153">			double[][] imArray = toDoubleArray(grayscale.getFloatArray());</span>
			
<span class="nc" id="L155">			Matrix imMat = Matrix.from2DArray(imArray);</span>
			//transpose back
<span class="nc" id="L157">			imMat=imMat.transpose();</span>
			
			// dimensions: row of subregion, col of subregion
<span class="nc" id="L160">			Matrix[][] regionArray = new Matrix[tileCountRow][tileCountCol]; //this is an array of matrices</span>
			
			//initialize holders for indices
<span class="nc" id="L163">			int r[]=new int[2];</span>
<span class="nc" id="L164">			int c[]=new int[2];</span>
			
			
			/*
			 * Iterates over full image, splits into subregions, and normalizes along the standard scheme 
			 * 
			 */
			
			//System.out.println(&quot;Splitting image into subregions...&quot;);
<span class="nc" id="L173">			String msg = (&quot;Splitting image into subregions...&quot;);</span>
<span class="nc" id="L174">			log.log(LogLevel.INFO, msg);</span>
			//log.info(msg);
<span class="nc" id="L176">			long start = System.nanoTime();</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">			for (int i=0; i&lt; tileCountRow; i++) {</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">				for (int j=0; j&lt; tileCountCol; j++) {</span>
					
<span class="nc" id="L180">					r[0]=i*tileHeight;</span>
<span class="nc" id="L181">					r[1]=(i+1)*tileHeight;</span>
<span class="nc" id="L182">					c[0]=j*tileWidth;</span>
<span class="nc" id="L183">					c[1]=(j+1)*tileWidth;</span>
					
					//2D indexing, add to full array of regions
					//fromrow, fromcol, torow, tocol. goes up to torow/tocol but does not include them, so second two indices should each be one more than where is wanted
<span class="nc" id="L187">					Matrix thisIm = imMat.slice(r[0], c[0], r[1], c[1]);</span>
					
					//normalize values by split intensities
					//use sum of boolean matrix? divide by that number?
<span class="nc" id="L191">					thisIm=thisIm.divide(thisIm.max());</span>
					
<span class="nc" id="L193">					double tot=thisIm.sum();</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">					if (tot&gt;.90*tileWidth*tileHeight) {</span>
						//leave this tile alone					
					}
					else {
<span class="nc" id="L198">						double[] SumStd = modSumStd(thisIm);</span>
						//System.out.println(&quot;tile intensity mean = &quot; + Double.toString(SumStd[0]) + &quot;tile intensity std = &quot; + Double.toString(SumStd[1]));
						
<span class="nc" id="L201">						thisIm=thisIm.subtract(SumStd[0]).divide(SumStd[1]*2);//.multiply(-1); //normalize</span>
					}
					
					
					//add to array of matrices
<span class="nc" id="L206">					thisIm=mirrorer(thisIm, mirrorNheight, mirrorNwidth);</span>
<span class="nc" id="L207">					regionArray[i][j]=thisIm;</span>
					
					
<span class="nc bnc" id="L210" title="All 2 branches missed.">					if (j==0) {</span>
						//System.out.println(Double.toString(100*i/(tileCountRow)) + &quot;% percent finished with splitting full image.&quot;);
<span class="nc" id="L212">						msg = (Double.toString(100*i/(tileCountRow)) + &quot;% percent finished with splitting full image.&quot;);</span>
						//log.info(msg);
<span class="nc" id="L214">						log.log(LogLevel.INFO, msg);</span>
					}
					
				}			
				
			}
<span class="nc" id="L220">			long finish=System.nanoTime();</span>
			//System.out.println(&quot;100% finished with splitting full image. Time elapsed = &quot; + Long.toString((finish-start)/1000000000) + &quot; seconds.&quot;);
<span class="nc" id="L222">			msg = (&quot;100% finished with splitting full image. Time elapsed = &quot; + Long.toString((finish-start)/1000000000) + &quot; seconds.&quot;);</span>
<span class="nc" id="L223">			log.log(LogLevel.INFO, msg);</span>
			//log.info(msg);
			/*
			 * Iterates over all split regions, converts them to tensor inputs, and applies the model 
			 * 
			 */
			
			//System.out.println(&quot;\n\nApplying model...&quot;);
<span class="nc" id="L231">			msg = (&quot;\n\nApplying model...&quot;);</span>
<span class="nc" id="L232">			log.log(LogLevel.INFO, msg);</span>
			//log.info(msg);
			
<span class="nc" id="L235">			start = System.nanoTime();</span>
<span class="nc" id="L236">			Matrix[][] outputArray = new Matrix[tileCountRow][tileCountCol]; //this is an array of matrices</span>
			//input each part to model
<span class="nc bnc" id="L238" title="All 2 branches missed.">			for (int i=0; i&lt; tileCountRow; i++) {</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">				for (int j=0; j&lt; tileCountCol; j++) {</span>
					
					//make input a tensor of undefined type and 4 dimensions
					//makes Matrix-&gt; DenseMatrix-&gt; 2D float array -&gt; 4D float array -&gt; 4D tensor in one line
<span class="nc" id="L243">					Tensor&lt;?&gt; input = Tensor.create(   addDims(toFloatArray(regionArray[i][j].toDenseMatrix().toArray()))    ); </span>
					
					//taken from microscopeImageFocusQualityClassifier
<span class="nc" id="L246">					SignatureDef sig = null;</span>
					try {
						//System.out.print(model.toString());
						//byte[] a=model.metaGraphDef();
<span class="nc" id="L250">						sig = MetaGraphDef.parseFrom(model.metaGraphDef()) //define signature</span>
<span class="nc" id="L251">								.getSignatureDefOrThrow(DEFAULT_SERVING_SIGNATURE_DEF_KEY);</span>
						
<span class="nc" id="L253">					} catch (InvalidProtocolBufferException e) {</span>
						// Catch if model does not parse signature statement
<span class="nc" id="L255">						e.printStackTrace();</span>
					}
					
<span class="nc" id="L258">					final List&lt;Tensor&lt;?&gt;&gt; fetches = model.session().runner() // run model with specified inputs, outputs, and operation</span>
<span class="nc" id="L259">							.feed(opName(sig.getInputsOrThrow(&quot;input_image&quot;)), input) //</span>
<span class="nc" id="L260">							.fetch(opName(sig.getOutputsOrThrow(&quot;output_map&quot;))) //</span>
<span class="nc" id="L261">							.run();</span>
					
					//get the results back from tensor format
<span class="nc" id="L264">					Tensor&lt;?&gt; output = fetches.get(0); //fetch output tensor, dimensions=4</span>
<span class="nc" id="L265">					float[][][][] dst = new float[1][tileHeight+2*mirrorNheight][tileWidth+2*mirrorNwidth][1]; // initialize intermediate variable</span>
<span class="nc" id="L266">					output.copyTo(dst);  // copy from tensor to java float array</span>
<span class="nc" id="L267">					outputArray[i][j] = Matrix.from2DArray(toDoubleArray(removeDims(dst))); //make matrix from double array and write it to our output array</span>
					
					/*
					//show tile results- for debugging
					FloatProcessor tileP = new FloatProcessor((removeDims(dst)));
					ImagePlus tileIm = new ImagePlus(&quot;output region&quot;, tileP);
					tileIm.show();
					*/
					
					
<span class="nc bnc" id="L277" title="All 2 branches missed.">					if (j==0) {</span>
						//System.out.println(Double.toString(100*i/(tileCountRow)) + &quot;% percent finished with applying model.&quot;);
<span class="nc" id="L279">						msg = (Double.toString(100*i/(tileCountRow)) + &quot;% percent finished with applying model.&quot;);</span>
<span class="nc" id="L280">						log.log(LogLevel.INFO, msg);</span>
						//log.info(msg);
					}
				}
			}
<span class="nc" id="L285">			finish=System.nanoTime();</span>
			
			//System.out.println(&quot;100% finished with applying model. Time elapsed = &quot; + Long.toString((finish-start)/1000000000) + &quot; seconds.&quot;);
<span class="nc" id="L288">			msg = (&quot;100% finished with applying model. Time elapsed = &quot; + Long.toString((finish-start)/1000000000) + &quot; seconds.&quot;);</span>
<span class="nc" id="L289">			log.log(LogLevel.INFO, msg);</span>
			//log.info(msg);
			
			//reconstruct full image- create full size zero matrix and use Matrix.insert() to write values where they are supposed to be
			//TODO make this faster
<span class="nc" id="L294">			Matrix fullOutput= Matrix.zero(height, width);</span>
<span class="nc" id="L295">			float[][] floatOutput = new float[height][width]; </span>
			
			
			/*
			 * Iterates over all outputs, indexes them to remove mirrored regions, and restores to full size image
			 * 
			 */
			//TODO this is faster than it was but still needs work
<span class="nc" id="L303">			System.out.println(&quot;\nRe-Unifying processed tiles...\n\n&quot;);</span>
<span class="nc" id="L304">			start=System.nanoTime();</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">			for (int i=0; i&lt; tileCountRow; i++) {</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">				for (int j=0; j&lt; tileCountCol; j++) {</span>
					//reverse mirroring. slice goes up to but does not include the last value, so param 3 and 4 should not be one less than they are
<span class="nc" id="L308">					outputArray[i][j]=outputArray[i][j].slice(mirrorNheight, mirrorNwidth, tileHeight+mirrorNheight, tileWidth+mirrorNwidth);</span>
<span class="nc" id="L309">					float[][] slice = toFloatArray(outputArray[i][j].toDenseMatrix().toArray());</span>
					//fullOutput = fullOutput.insert(outputArray[i][j], i*tileHeight, j*tileWidth, tileHeight, tileWidth );
					
<span class="nc bnc" id="L312" title="All 2 branches missed.">					for (int i1=0; i1&lt; tileHeight; i1++) {</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">						for (int j1=0; j1&lt; tileWidth; j1++) {</span>
<span class="nc" id="L314">							floatOutput[i1+i*tileHeight][j1+j*tileWidth]=slice[i1][j1];</span>
						}
					}
					
					if (j==0) {
						//System.out.println(Double.toString(100*i/(tileCountRow)) + &quot;% percent finished with re-unifying tiles&quot;);
					}
				}
			}
<span class="nc" id="L323">			finish=System.nanoTime();</span>
			//System.out.println(&quot;100% finished with re-unifying tiles. Time elapsed = &quot; + Long.toString((finish-start)/1000000000) + &quot; seconds.\n&quot;);
<span class="nc" id="L325">			fullOutput=Matrix.from2DArray(toDoubleArray(floatOutput));</span>
<span class="nc" id="L326">			fullOutput=fullOutput.divide(1000);</span>
<span class="nc" id="L327">			double sum = fullOutput.sum();</span>
<span class="nc" id="L328">			fullOutput=fullOutput.divide(fullOutput.max()*3/2 );</span>
			//convert this full matrix back to double array
<span class="nc" id="L330">			fullOutput.multiply(Math.pow(2, 32)); //normalize to 32bit for the FloatProcessor and display</span>
<span class="nc" id="L331">			double[][] densityMap = fullOutput.transpose().toDenseMatrix().toArray(); //transpose back and make double array</span>
			
			//display heat map
<span class="nc" id="L334">			FloatProcessor densityMapFlp = new FloatProcessor(toFloatArray(densityMap));</span>
<span class="nc" id="L335">			ImagePlus display = new ImagePlus(&quot;Count Density Map&quot;, densityMapFlp);</span>
			
			//System.out.println (&quot;Total count = &quot; + Double.toString(sum));
<span class="nc" id="L338">			msg = (&quot;Total count = &quot; + Double.toString(sum));</span>
<span class="nc" id="L339">			log.log(LogLevel.INFO, msg);</span>
			//log.info(msg);
			
<span class="nc" id="L342">			display.show();</span>
			
			
			
			//TODO apply grid
			/*
			if (grid) {
				
			}
			*/
			
<span class="nc" id="L353">		}</span>
			
		
		
		
		
	    /**
	     * Computes modified mean and standard deviation of image intensity 
	     *(does not consider brightest regions)
	     * 
	     *
	     * 
	     */
	    double[] modSumStd(Matrix in) {
<span class="nc" id="L367">	    	double[] values = new double[2];</span>
<span class="nc" id="L368">	    	int n = 0;</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">	    	for (int i = 0; i &lt; in.rows(); i++) {</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">				  for (int j = 0; j &lt; in.columns(); j++) {</span>
<span class="nc" id="L371">					  double val = in.get(i, j);</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">					  if (val&lt;.90) {</span>
<span class="nc" id="L373">						  values[0] = values[0] + val;</span>
<span class="nc" id="L374">						  n=n+1;</span>
					  }
				  }
			 }
	    	
<span class="nc" id="L379">	    	values[0]=values[0]/n;</span>
<span class="nc" id="L380">	    	double diffs = 0;</span>
<span class="nc" id="L381">	    	n=0;</span>
	    	
<span class="nc bnc" id="L383" title="All 2 branches missed.">	    	for (int i = 0; i &lt; in.rows(); i++) {</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">				  for (int j = 0; j &lt; in.columns(); j++) {</span>
<span class="nc" id="L385">					  double val = in.get(i, j);</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">					  if (val&lt;.90) {</span>
<span class="nc" id="L387">						  diffs = diffs + Math.pow((val - values[0]),2);</span>
<span class="nc" id="L388">						  n=n+1;</span>
					  }
				  }
			 }
<span class="nc" id="L392">	    	values[1] = Math.sqrt(diffs/n);</span>
	    	
	    	
<span class="nc" id="L395">			return values;</span>
	    }
		
		double[][] toDoubleArray(float[][] arr) {
<span class="nc bnc" id="L399" title="All 2 branches missed.">			  if (arr == null) return null;</span>
<span class="nc" id="L400">			  int r = arr.length;</span>
<span class="nc" id="L401">			  int c = arr[0].length;</span>
<span class="nc" id="L402">			  double[][] ret = new double[r][c];</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">			  for (int i = 0; i &lt; r; i++) {</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">				  for (int j = 0; j &lt; c; j++) {</span>
<span class="nc" id="L405">					  ret[i][j] = (double)arr[i][j];</span>
				  }
			  }
<span class="nc" id="L408">			  return ret;</span>
			}
		
		float[][] toFloatArray(double[][] arr) {
<span class="nc bnc" id="L412" title="All 2 branches missed.">			  if (arr == null) return null;</span>
<span class="nc" id="L413">			  int r = arr.length;</span>
<span class="nc" id="L414">			  int c = arr[0].length;</span>
<span class="nc" id="L415">			  float[][] ret = new float[r][c];</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">			  for (int i = 0; i &lt; r; i++) {</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">				  for (int j = 0; j &lt; c; j++) {</span>
<span class="nc" id="L418">					  ret[i][j] = (float)arr[i][j];</span>
				  }
			  }
<span class="nc" id="L421">			  return ret;</span>
			}
		
		
		 private static SavedModelBundle getModel() {
				//load model
			 	//TODO fix
<span class="nc" id="L428">				HTTPLocation source = null;</span>
<span class="nc" id="L429">				SavedModelBundle model = null;</span>
<span class="nc" id="L430">				try {source = new HTTPLocation(MODEL_URL);} catch (final Exception e) {log.error(e);}</span>
<span class="nc" id="L431">				try {model = tensorFlowService.loadModel(source, MODEL_NAME, MODEL_TAG);}</span>
<span class="nc" id="L432">				catch (final Exception e) { log.error(e);} // Use the LogService to report the error</span>
<span class="nc" id="L433">				return model;</span>
			}
		
		
		// 
		//  
		 /**Returns a matrix with mirrored edges along the pattern used to train AxoNet.
			 * mirrors to the point of dimensions as multiples of 32
			 * 
			 *
			 * @param n number of pixel rows to expand in each direction
			 * @return matrix with mirrored edges.
			 */
		Matrix mirrorer(Matrix region, int mirrorNheight, int mirrorNwidth) {
<span class="nc bnc" id="L447" title="All 2 branches missed.">			for (int i=0; i&lt;mirrorNheight; i++) {</span>
				//System.out.println(region.rows());
<span class="nc" id="L449">				region=region.insertRow(0, region.getRow(2*i));</span>
				//System.out.println(region.rows());
				//region=region.insertRow(region.rows(), region.getRow((region.rows()-1)-2*i));
<span class="nc" id="L452">				region=addRow(region, region.rows(), region.getRow((region.rows()-1)-2*i));</span>
			}
<span class="nc bnc" id="L454" title="All 2 branches missed.">			for (int i=0; i&lt;mirrorNwidth; i++) {</span>
<span class="nc" id="L455">				region=region.insertColumn(0, region.getColumn(2*i));</span>
				//region=region.insertColumn(region.columns(), region.getColumn((region.columns()-1)-2*i));
<span class="nc" id="L457">				region=addColumn(region, region.columns(), region.getColumn((region.columns()-1)-2*i));</span>
			}
<span class="nc" id="L459">			return region;</span>
		}
		
		
		/**
		 * The SignatureDef inputs and outputs contain names of the form
		 * {@code &lt;operation_name&gt;:&lt;output_index&gt;}, where for this model,
		 * {@code &lt;output_index&gt;} is always 0. This function trims the {@code :0}
		 * suffix to get the operation name.
		 */
		private static String opName(final TensorInfo t) {
<span class="nc" id="L470">			final String n = t.getName();</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">			if (n.endsWith(&quot;:0&quot;)) {</span>
<span class="nc" id="L472">				return n.substring(0, n.lastIndexOf(&quot;:0&quot;));</span>
			}
<span class="nc" id="L474">			return n;</span>
			
		}
		
		
		/**Modification from 'insertRow' to allow adding to end of row
		 * 
		 * Adds one row to matrix.
		 *
		 * @param i the row index
		 * @return matrix with row.
		 */
		public static Matrix addRow(Matrix to, int i, Vector row) {
<span class="nc bnc" id="L487" title="All 4 branches missed.">		    if (i &gt; to.rows() || i &lt; 0) {</span>
<span class="nc" id="L488">		        throw new IndexOutOfBoundsException(&quot;Illegal row number, must be 0..&quot; + (to.rows() - 1));</span>
		    }

<span class="nc" id="L491">		    Matrix result = to.blankOfShape(to.rows() + 1, to.columns());</span>

<span class="nc bnc" id="L493" title="All 2 branches missed.">		    for (int ii = 0; ii &lt; i; ii++) {</span>
<span class="nc" id="L494">		        result.setRow(ii, to.getRow(ii));</span>
		    }

<span class="nc" id="L497">		    result.setRow(i, row);</span>

<span class="nc bnc" id="L499" title="All 2 branches missed.">		    for (int ii = i; ii &lt; to.rows(); ii++) {</span>
<span class="nc" id="L500">		        result.setRow(ii + 1, to.getRow(ii));</span>
		    }

<span class="nc" id="L503">		    return result;</span>
		}
		
		/**Modification from 'insertColumn' to allow adding to end of column
		 * 
		 * Adds one column to matrix.
		 *
		 * @param j the column index
		 * @return matrix with column.
		 */
		public static Matrix addColumn(Matrix to, int j, Vector column) {
<span class="nc bnc" id="L514" title="All 4 branches missed.">		    if (j &gt; to.columns() || j &lt; 0) {</span>
<span class="nc" id="L515">		        throw new IndexOutOfBoundsException(&quot;Illegal row number, must be 0..&quot; + (to.columns() - 1));</span>
		    }

<span class="nc" id="L518">		    Matrix result = to.blankOfShape(to.rows(), to.columns() + 1);</span>

<span class="nc bnc" id="L520" title="All 2 branches missed.">		    for (int jj = 0; jj &lt; j; jj++) {</span>
<span class="nc" id="L521">		        result.setColumn(jj, to.getColumn(jj));</span>
		    }

<span class="nc" id="L524">		    result.setColumn(j, column);</span>

<span class="nc bnc" id="L526" title="All 2 branches missed.">		    for (int jj = j; jj &lt; to.columns(); jj++) {</span>
<span class="nc" id="L527">		        result.setColumn(jj + 1, to.getColumn(jj));</span>
		    }

<span class="nc" id="L530">		    return result;</span>
		}
		
		public static float[][][][] addDims(float [][] in) {
<span class="nc" id="L534">			float[][][][] out= new float[1][in.length][in[0].length][1];</span>
			
<span class="nc bnc" id="L536" title="All 2 branches missed.">			for (int i=0; i&lt; in.length; i++) {</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">				for (int j=0; j&lt; in[0].length; j++) {</span>
<span class="nc" id="L538">					out[0][i][j][0]=in[i][j];</span>
				}
			}
			
<span class="nc" id="L542">			return out;</span>
		}
		
		public static float[][] removeDims(float [][][][] in) {
<span class="nc" id="L546">			float[][] out= new float[in[0].length][in[0][0].length];</span>
			
<span class="nc bnc" id="L548" title="All 2 branches missed.">			for (int i=0; i&lt; in[0].length; i++) {</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">				for (int j=0; j&lt; in[0][0].length; j++) {</span>
<span class="nc" id="L550">					out[i][j] = in[0][i][j][0];</span>
				}
			}
			
<span class="nc" id="L554">			return out;</span>
		}
		
}






</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>